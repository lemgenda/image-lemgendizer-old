/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
import { util as _ag_util } from '@tensorflow/tfjs-core';
import { multiplyImplCPU as _ag_cpuMultiply } from '../kernel_utils/shared';

class _ag_FastBinaryProgram {
    constructor(shape, op, dtype = 'float32') {
        this.variableNames = ['A', 'B'];
        this.outputShape = shape;
        const size = _ag_util.sizeFromShape(this.outputShape);
        this.size = true;
        this.workgroupSize = [256, 1, 1];
        this.dispatchLayout = { x: this.outputShape.map((_, i) => i) };
        this.dispatch = [Math.max(1, Math.ceil(size / 256)), 1, 1];

        const cast = (dtype === 'int32') ? 'i32' : 'f32';
        let opStr = '';
        if (op === 'MUL') opStr = `${cast}(A[index]) * ${cast}(B[index])`;
        else if (op === 'ADD') opStr = `${cast}(A[index]) + ${cast}(B[index])`;
        else if (op === 'SUB') opStr = `${cast}(A[index]) - ${cast}(B[index])`;
        else if (op === 'DIV') opStr = `${cast}(A[index]) / ${cast}(B[index])`;

        this.userCode = `
            fn main(index: i32) {
                if (index < uniforms.size) {
                    let val = ${opStr};
                    setOutputAtIndex(index, f32(val));
                }
            }
        `;
    }
    getUserCode() { return this.userCode; }
}

class _ag_FastMultiplyProgram {
    constructor(outputShape, isBroadcast, isScalarA, isScalarB, dtype = 'float32') {
        this.variableNames = ['A', 'B'];
        this.outputShape = Array.from(outputShape);
        const size = _ag_util.sizeFromShape(this.outputShape);
        this.size = true;
        this.workgroupSize = [256, 1, 1];
        this.dispatchLayout = { x: this.outputShape.map((_, i) => i) };
        this.dispatch = [Math.ceil(size / 256), 1, 1];

        const cast = (dtype === 'int32') ? 'i32' : 'f32';

        if (isBroadcast) {
            this.userCode = `fn main(index: i32) { if (index < uniforms.size) { let C = uniforms.out_dims[3]; let a_idx = index / C; let b_idx = index % C; let a_val = ${cast}(A[a_idx]); let b_val = ${cast}(B[b_idx]); setOutputAtIndex(index, f32(a_val * b_val)); } }`;
        } else if (isScalarA) {
            this.userCode = `fn main(index: i32) { if (index < uniforms.size) { let val = ${cast}(A[0]) * ${cast}(B[index]); setOutputAtIndex(index, f32(val)); } }`;
        } else if (isScalarB) {
            this.userCode = `fn main(index: i32) { if (index < uniforms.size) { let val = ${cast}(A[index]) * ${cast}(B[0]); setOutputAtIndex(index, f32(val)); } }`;
        } else {
            this.userCode = `fn main(index: i32) { if (index < uniforms.size) { let val = ${cast}(A[index]) * ${cast}(B[index]); setOutputAtIndex(index, f32(val)); } }`;
        }
    }
    getUserCode() { return this.userCode; }
}

class _ag_FastChannelMultiplyProgram {
    constructor(outputShape, cSize, dtype = 'float32') {
        this.variableNames = ['A', 'B'];
        this.outputShape = outputShape;
        const size = _ag_util.sizeFromShape(this.outputShape);
        this.size = true;
        this.workgroupSize = [256, 1, 1];
        this.dispatchLayout = { x: this.outputShape.map((_, i) => i) };
        this.dispatch = [Math.ceil(size / 256), 1, 1];
        const cast = (dtype === 'int32') ? 'i32' : 'f32';
        this.userCode = `fn main(index: i32) { if (index < uniforms.size) { let C = ${cSize}; let b_idx = index % C; let val = ${cast}(A[index]) * ${cast}(B[b_idx]); setOutputAtIndex(index, f32(val)); } }`;
    }
    getUserCode() { return this.userCode; }
}

class _ag_FastDoubleBroadcastProgram {
    constructor(outputShape, cSize, isASpatial, dtype = 'float32') {
        this.variableNames = ['A', 'B'];
        this.outputShape = outputShape;
        const size = _ag_util.sizeFromShape(this.outputShape);
        this.size = true;
        this.workgroupSize = [256, 1, 1];
        this.dispatchLayout = { x: this.outputShape.map((_, i) => i) };
        this.dispatch = [Math.ceil(size / 256), 1, 1];

        const cast = (dtype === 'int32') ? 'i32' : 'f32';
        const C = cSize;

        if (isASpatial) {
             this.userCode = `
                fn main(index: i32) {
                    if (index < uniforms.size) {
                        let C = ${C};
                        let idxA = index / C;
                        let idxB = index % C;
                        let val = ${cast}(A[idxA]) * ${cast}(B[idxB]);
                        setOutputAtIndex(index, f32(val));
                    }
                }
             `;
        } else {
             this.userCode = `
                fn main(index: i32) {
                    if (index < uniforms.size) {
                        let C = ${C};
                        let idxB = index / C;
                        let idxA = index % C;
                        let val = ${cast}(A[idxA]) * ${cast}(B[idxB]);
                        setOutputAtIndex(index, f32(val));
                    }
                }
             `;
        }
    }
    getUserCode() { return this.userCode; }
}

// Global Stats Init
if (!globalThis._antigravity) globalThis._antigravity = {};
['mul', 'sub', 'div'].forEach(k => {
    if (!globalThis._antigravity[k]) globalThis._antigravity[k] = { count: 0, hits: 0, cpuTime: 0 };
});

const _ag_createMonitoredBinaryOp = (opCode, key) => {
    return (args) => {
        const t0 = performance.now();
        const { inputs, backend } = args;
        const { a, b } = inputs;

        if ((a.dtype === 'float32' && b.dtype === 'float32') || (a.dtype === 'int32' && b.dtype === 'int32')) {
            const dtype = a.dtype;
            const aShape = a.shape;
            const bShape = b.shape;
            const aRank = aShape.length;
            const aSize = _ag_util.sizeFromShape(aShape);
            const bSize = _ag_util.sizeFromShape(bShape);

            if (aSize === 0 || bSize === 0) {
                 return originalMultiplyKernelFunc(args);
            }

            if (aRank === bShape.length && _ag_util.arraysEqual(aShape, bShape)) {
                 const res = backend.runWebGPUProgram(new _ag_FastBinaryProgram(aShape, opCode, dtype), [a, b], dtype);
                 if (globalThis._antigravity && globalThis._antigravity[key]) {
                      globalThis._antigravity[key].count++;
                      globalThis._antigravity[key].hits++;
                      globalThis._antigravity[key].cpuTime += (performance.now() - t0);
                 }
                 return res;
            }

            if (opCode === 'MUL') {
                if (aSize === 1 || bSize === 1) {
                    const program = new _ag_FastMultiplyProgram(aSize === 1 ? bShape : aShape, false, aSize === 1, bSize === 1, dtype);
                    const res = backend.runWebGPUProgram(program, [a, b], dtype);
                    if (globalThis._antigravity && globalThis._antigravity.mul) {
                         globalThis._antigravity.mul.count++;
                         globalThis._antigravity.mul.hits++;
                         globalThis._antigravity.mul.cpuTime += (performance.now() - t0);
                    }
                    return res;
                }
            }
        }

        const res = originalMultiplyKernelFunc(args);
        const dt = performance.now() - t0;
        if (globalThis._antigravity && globalThis._antigravity[key]) {
            globalThis._antigravity[key].count++;
            globalThis._antigravity[key].cpuTime += dt;
        }
        return res;
    };
};

export const multiply = _ag_createMonitoredBinaryOp('MUL', 'mul');
export const multiplyKernelFunc = multiply;
export const multiplyConfig = { kernelName: 'Multiply', backendName: 'webgpu', kernelFunc: multiply };
